// Usage is analogue to the official stringer (go/x/tools/stringer), except that
// -type cannot be a list, but needs to be a single type.
//
// go:generate go run genops.go -type=<operator_type_name>
//
//go:build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/redraskal/r6-dissect/dissect/ubi"
	"golang.org/x/tools/go/packages"
)

var typeName = flag.String("type", "", "operator type name; must be set")

// main (and most of this file) is heavily inspired by go/x/tools/stringer
func main() {
	log.SetFlags(0)
	log.SetPrefix("genops: ")
	flag.Parse()

	// validate -type flag is set
	if len(*typeName) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	// assemble full path to invoking file
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	srcFile := path.Join(cwd, os.Getenv("GOFILE"))

	g := Generator{
		operatorTypeName: *typeName,
		roleTypeName:     "OperatorRole",
		roleValueAtk:     "Atk",
		roleValueDef:     "Def",
	}

	// load input package
	g.parseSrcFile(srcFile)

	g.generate()

	// Format the output.
	src := g.format()

	// Write to file.
	baseName := fmt.Sprintf("%s_roles.go", *typeName)
	outFile := filepath.Join(cwd, strings.ToLower(baseName))
	if err = ioutil.WriteFile(outFile, src, 0644); err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

type Generator struct {
	buf              bytes.Buffer
	operatorTypeName string
	roleTypeName     string
	roleValueAtk     string
	roleValueDef     string
	pkgName          string
	operatorConsts   []*types.Const
}

func (g *Generator) parseSrcFile(file string) {
	cfg := &packages.Config{
		Mode:  packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo,
		Tests: false,
	}
	pkgs, err := packages.Load(cfg, file)
	if err != nil {
		log.Fatal(err)
	}
	// validate we have exactly *one* package
	// (since we only accept exactly one type, we should also only get one package)
	if len(pkgs) == 0 {
		log.Fatalf("error: no packages found in %s", file)
	} else if len(pkgs) > 1 {
		log.Fatalf("error: expected exactly 1 package, got %d", len(pkgs))
	}
	g.loadPackage(pkgs[0])
}

func (g *Generator) loadPackage(pkg *packages.Package) {
	g.pkgName = pkg.Name
	operatorConsts := make([]*types.Const, 0, 100)

	// find all constants that have our target type
	scope := pkg.Types.Scope()
	targetType := scope.Lookup(g.operatorTypeName).Type()
	for _, obj := range pkg.TypesInfo.Defs {
		// assert that types matches
		if obj != nil && obj.Type() == targetType {
			// assert that value is const
			if v, ok := obj.(*types.Const); ok {
				operatorConsts = append(operatorConsts, v)
			}
		}
	}

	if len(operatorConsts) == 0 {
		log.Fatalf("error: did not find any constants of type \"%s\" in package %s", g.operatorTypeName, pkg.Name)
	}
	g.operatorConsts = operatorConsts
}

func (g *Generator) generate() {
	g.printHeader()

	// role type
	g.printf("type %s int\n\n", g.roleTypeName)
	g.printf("const (\n")
	g.printf("%s %s = iota\n", g.roleValueAtk, g.roleTypeName)
	g.printf("%s\n", g.roleValueDef)
	g.printf(")\n")

	log.Println("retrieving operator data from Ubisoft")
	// map[Operator]Role
	ops, err := ubi.GetOperatorMap()
	if err != nil {
		log.Fatalln(err)
	}

	log.Println("creating operator role map")
	g.printf("var _operatorRoles = map[%s]%s{\n", g.operatorTypeName, g.roleTypeName)
	for _, c := range g.operatorConsts {
		constNameLower := strings.ToLower(c.Name())
		op, exists := ops[constNameLower]
		if !exists {
			log.Printf("WARNING: operator const \"%s\" not present in Ubisoft data\n", c.Name())
			log.Println("         either add it manually or check the const name")
		}

		var roleVal string
		if op.IsAttacker {
			roleVal = g.roleValueAtk
		} else {
			roleVal = g.roleValueDef
		}
		g.printf("%s: %s,\n", c.Val().ExactString(), roleVal)
	}
	g.printf("}\n")

	g.printGetter()
}

func (g *Generator) printHeader() {
	g.printf("// Code generated by \"genops.go %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.printf("package %s\n", g.pkgName)
	g.printf("\n")
	g.printf("import \"errors\"\n")
}

func (g *Generator) printGetter() {
	g.printf("func (i Operator) Role() (%s, error) {\n", g.roleTypeName)
	g.printf("if r, ok := _operatorRoles[i]; ok {\n")
	g.printf("return r, nil\n")
	g.printf("}\n")
	g.printf(`return 0, errors.New("role unknown for this operator")`)
	g.printf("}\n")
}

func (g *Generator) printf(format string, args ...any) {
	fmt.Fprintf(&g.buf, format, args...)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}
